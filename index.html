<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quaternion Julia Set Explorer - 4K Real-time Fractal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 30, 0.9);
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            width: 180px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 11px;
        }
        
        #controls h3 {
            margin-bottom: 8px;
            color: #00ffcc;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
            border-bottom: 1px solid rgba(0, 255, 204, 0.3);
            padding-bottom: 3px;
            font-size: 12px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 10px;
            color: #aaa;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .slider-container label {
            width: 12px;
            margin-right: 5px;
            margin-bottom: 0;
            font-size: 9px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            background: #00ffcc;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 10px;
            height: 10px;
            background: #00ffcc;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        
        .value-display {
            width: 35px;
            margin-left: 5px;
            font-size: 9px;
            color: #00ffcc;
            text-align: right;
        }
        
        input[type="checkbox"] {
            margin-right: 4px;
            transform: scale(0.8);
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            font-size: 10px;
        }
        
        select {
            width: 100%;
            padding: 3px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-bottom: 5px;
            font-size: 10px;
            cursor: pointer;
        }
        
        select option {
            background: #333;
            color: #fff;
            padding: 5px;
        }
        
        select:focus {
            outline: 1px solid #00ffcc;
        }
        
        #fps {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-family: monospace;
            font-size: 16px;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            max-width: 200px;
        }
        
        #info kbd {
            background: rgba(255, 255, 255, 0.2);
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 9px;
        }
        
        button {
            width: 100%;
            padding: 5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 5px;
            transition: transform 0.2s;
            font-size: 10px;
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #play-button {
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            margin-bottom: 5px;
        }
        
        #play-button.playing {
            background: linear-gradient(135deg, #ff4444 0%, #ff8888 100%);
        }
        
        #animation-status {
            font-size: 9px;
            color: #00ffcc;
            text-align: center;
            margin-top: 3px;
            margin-bottom: 5px;
            height: 12px;
        }
        
        .color-picker {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .color-picker input[type="color"] {
            width: 25px;
            height: 20px;
            border: none;
            border-radius: 3px;
            margin-right: 5px;
            cursor: pointer;
        }
        
        .color-picker label {
            flex: 1;
            margin-bottom: 0;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="fps">FPS: 0</div>
    <div id="info">
        <strong>Controls:</strong><br>
        <kbd>↑</kbd><kbd>↓</kbd> Pitch | <kbd>←</kbd><kbd>→</kbd> Yaw<br>
        <kbd>W</kbd><kbd>S</kbd> Forward/Back | <kbd>A</kbd><kbd>D</kbd> Strafe<br>
        <kbd>Q</kbd><kbd>E</kbd> Up/Down | <kbd>Shift</kbd> Speed boost
    </div>
    
    <div id="controls">
        <h3>Quaternion Julia Set</h3>
        
        <button id="play-button">▶ Play Animation</button>
        <div id="animation-status"></div>
        
        <div class="control-group">
            <label>Julia Constant K</label>
            <div class="slider-container">
                <label>X</label>
                <input type="range" id="kx" min="-2" max="2" step="0.01" value="-0.2">
                <span class="value-display" id="kx-val">-0.2</span>
            </div>
            <div class="slider-container">
                <label>Y</label>
                <input type="range" id="ky" min="-2" max="2" step="0.01" value="0.6">
                <span class="value-display" id="ky-val">0.6</span>
            </div>
            <div class="slider-container">
                <label>Z</label>
                <input type="range" id="kz" min="-2" max="2" step="0.01" value="0.2">
                <span class="value-display" id="kz-val">0.2</span>
            </div>
            <div class="slider-container">
                <label>W</label>
                <input type="range" id="kw" min="-2" max="2" step="0.01" value="-0.2">
                <span class="value-display" id="kw-val">-0.2</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Color Palette</label>
            <select id="palette-preset">
            </select>
            
            <div id="custom-colors" style="display: none;">
                <div class="color-picker">
                    <input type="color" id="color1" value="#001166">
                    <label>Base Color</label>
                </div>
                <div class="color-picker">
                    <input type="color" id="color2" value="#00ffcc">
                    <label>Mid Color</label>
                </div>
                <div class="color-picker">
                    <input type="color" id="color3" value="#ff00ff">
                    <label>Peak Color</label>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Lighting</label>
            <div class="checkbox-container">
                <input type="checkbox" id="directional" checked>
                <label for="directional">Directional Light</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="ambient-occlusion" checked>
                <label for="ambient-occlusion">Ambient Occlusion</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="glow" checked>
                <label for="glow">Emissive Glow</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="shadows" checked>
                <label for="shadows">Shadows</label>
            </div>
        </div>
        
        <div class="control-group">
            <label>Rendering</label>
            <div class="slider-container">
                <label>Detail</label>
                <input type="range" id="iterations" min="5" max="200" step="5" value="100">
                <span class="value-display" id="iterations-val">100</span>
            </div>
            <div class="slider-container">
                <label>Slice W</label>
                <input type="range" id="slice" min="-2" max="2" step="0.01" value="0">
                <span class="value-display" id="slice-val">0.0</span>
            </div>
        </div>
        
        <button id="reset-camera">Reset Camera</button>
        <button id="random-julia">Random Julia Set</button>
        <button id="screenshot">Take Screenshot</button>
    </div>

    <script>
        // WebGL setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { 
            antialias: false,
            powerPreference: "high-performance",
            preserveDrawingBuffer: true 
        });
        
        if (!gl) {
            alert('WebGL 2 not supported!');
            throw new Error('WebGL 2 not supported');
        }

        // Set canvas size - default to 4K if possible
        let targetWidth = 3840;
        let targetHeight = 2160;
        let currentScale = 1.0;
        
        function resizeCanvas() {
            const maxWidth = window.innerWidth;
            const maxHeight = window.innerHeight;
            
            // Start with 4K and scale down if needed
            if (targetWidth > maxWidth || targetHeight > maxHeight) {
                const scale = Math.min(maxWidth / targetWidth, maxHeight / targetHeight);
                canvas.width = Math.floor(targetWidth * scale);
                canvas.height = Math.floor(targetHeight * scale);
            } else {
                canvas.width = targetWidth;
                canvas.height = targetHeight;
            }
            
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Vertex shader
        const vertexShaderSource = `#version 300 es
        in vec2 a_position;
        out vec2 v_uv;
        
        void main() {
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }`;

        // Fragment shader - Quaternion Julia Set ray marcher
        const fragmentShaderSource = `#version 300 es
        precision highp float;
        
        in vec2 v_uv;
        out vec4 fragColor;
        
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec4 u_juliaC;
        uniform vec3 u_cameraPos;
        uniform mat3 u_cameraRot;
        uniform float u_sliceW;
        uniform int u_iterations;
        
        // Color palette
        uniform vec3 u_color1;
        uniform vec3 u_color2;
        uniform vec3 u_color3;
        
        // Lighting toggles
        uniform bool u_directional;
        uniform bool u_ambientOcclusion;
        uniform bool u_glow;
        uniform bool u_shadows;
        
        // Quaternion multiplication
        vec4 qmul(vec4 a, vec4 b) {
            return vec4(
                a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,
                a.x * b.y + a.y * b.x + a.z * b.w - a.w * b.z,
                a.x * b.z - a.y * b.w + a.z * b.x + a.w * b.y,
                a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x
            );
        }
        
        // Quaternion Julia distance estimation
        float juliaDE(vec3 pos) {
            vec4 z = vec4(pos, u_sliceW);
            vec4 dz = vec4(1.0, 0.0, 0.0, 0.0);
            
            float r = 0.0;
            for(int i = 0; i < 150; i++) {
                if(i >= u_iterations) break;
                
                // Derivative
                dz = 2.0 * qmul(z, dz);
                
                // Julia iteration
                z = qmul(z, z) + u_juliaC;
                
                r = length(z);
                if(r > 4.0) break;
            }
            
            return 0.5 * r * log(r) / length(dz);
        }
        
        // Get normal
        vec3 getNormal(vec3 p) {
            vec2 e = vec2(0.0001, 0.0);
            return normalize(vec3(
                juliaDE(p + e.xyy) - juliaDE(p - e.xyy),
                juliaDE(p + e.yxy) - juliaDE(p - e.yxy),
                juliaDE(p + e.yyx) - juliaDE(p - e.yyx)
            ));
        }
        
        // Soft shadow
        float softShadow(vec3 ro, vec3 rd, float mint, float maxt) {
            if(!u_shadows) return 1.0;
            
            float res = 1.0;
            float t = mint;
            for(int i = 0; i < 16; i++) {
                float h = juliaDE(ro + rd * t);
                res = min(res, 8.0 * h / t);
                t += clamp(h, 0.02, 0.10);
                if(h < 0.001 || t > maxt) break;
            }
            return clamp(res, 0.0, 1.0);
        }
        
        // Ambient occlusion
        float ambientOcclusion(vec3 pos, vec3 nor) {
            if(!u_ambientOcclusion) return 1.0;
            
            float occ = 0.0;
            float sca = 1.0;
            for(int i = 0; i < 5; i++) {
                float hr = 0.01 + 0.12 * float(i) / 4.0;
                vec3 aopos = nor * hr + pos;
                float dd = juliaDE(aopos);
                occ += -(dd - hr) * sca;
                sca *= 0.95;
            }
            return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
        }
        
        // Ray marching
        float rayMarch(vec3 ro, vec3 rd, out int steps) {
            float t = 0.0;
            steps = 0;
            
            for(int i = 0; i < 200; i++) {
                vec3 pos = ro + rd * t;
                float d = juliaDE(pos);
                
                if(d < 0.0001 * t || t > 20.0) {
                    steps = i;
                    break;
                }
                
                t += d * 0.9;
                steps = i;
            }
            
            return t;
        }
        
        void main() {
            vec2 uv = (v_uv - 0.5) * vec2(u_resolution.x / u_resolution.y, 1.0);
            
            // Camera ray
            vec3 ro = u_cameraPos;
            vec3 rd = normalize(u_cameraRot * vec3(uv * 2.0, 2.0));
            
            // Ray march
            int steps;
            float t = rayMarch(ro, rd, steps);
            
            vec3 color = vec3(0.02, 0.02, 0.05); // Background
            
            if(t < 20.0) {
                vec3 pos = ro + rd * t;
                vec3 nor = getNormal(pos);
                
                // Base color from iterations
                float iterFactor = float(steps) / float(u_iterations);
                vec3 baseColor = mix(u_color1, u_color2, iterFactor);
                baseColor = mix(baseColor, u_color3, pow(iterFactor, 2.0));
                
                // Lighting
                vec3 lightDir = normalize(vec3(0.5, 0.7, 0.6));
                float diff = u_directional ? max(dot(nor, lightDir), 0.0) : 0.5;
                
                // Shadows
                float shadow = softShadow(pos + nor * 0.001, lightDir, 0.001, 3.0);
                
                // AO
                float ao = ambientOcclusion(pos, nor);
                
                // Specular
                vec3 halfDir = normalize(lightDir - rd);
                float spec = u_directional ? pow(max(dot(nor, halfDir), 0.0), 32.0) : 0.0;
                
                // Combine lighting
                color = baseColor * (0.3 + 0.7 * diff * shadow) * ao;
                color += vec3(1.0) * spec * shadow * 0.5;
                
                // Emissive glow
                if(u_glow) {
                    float glowAmount = pow(1.0 - iterFactor, 3.0);
                    color += baseColor * glowAmount * 0.5;
                }
                
                // Fog
                float fog = exp(-t * 0.1);
                color = mix(vec3(0.02, 0.02, 0.05), color, fog);
            }
            
            // Tone mapping and gamma
            color = color / (color + vec3(1.0));
            color = pow(color, vec3(1.0/2.2));
            
            fragColor = vec4(color, 1.0);
        }`;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }

        // Get uniform locations
        const uniforms = {
            resolution: gl.getUniformLocation(program, 'u_resolution'),
            time: gl.getUniformLocation(program, 'u_time'),
            juliaC: gl.getUniformLocation(program, 'u_juliaC'),
            cameraPos: gl.getUniformLocation(program, 'u_cameraPos'),
            cameraRot: gl.getUniformLocation(program, 'u_cameraRot'),
            sliceW: gl.getUniformLocation(program, 'u_sliceW'),
            iterations: gl.getUniformLocation(program, 'u_iterations'),
            color1: gl.getUniformLocation(program, 'u_color1'),
            color2: gl.getUniformLocation(program, 'u_color2'),
            color3: gl.getUniformLocation(program, 'u_color3'),
            directional: gl.getUniformLocation(program, 'u_directional'),
            ambientOcclusion: gl.getUniformLocation(program, 'u_ambientOcclusion'),
            glow: gl.getUniformLocation(program, 'u_glow'),
            shadows: gl.getUniformLocation(program, 'u_shadows')
        };

        // Create vertex buffer
        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');

        // Camera state
        let camera = {
            pos: [0, 0, -3],
            rot: [0, 0],
            moveSpeed: 0.05,
            rotSpeed: 0.02
        };

        // Input state
        const keys = {};
        
        // Parameters
        let juliaC = [-0.2, 0.6, 0.2, -0.2];
        let sliceW = 0.0;
        let iterations = 100;
        
        // Color palettes
        const palettes = {
            cosmic: {
                color1: [0.0, 0.07, 0.4],
                color2: [0.0, 1.0, 0.8],
                color3: [1.0, 0.0, 1.0]
            },
            fire: {
                color1: [0.2, 0.0, 0.0],
                color2: [1.0, 0.4, 0.0],
                color3: [1.0, 1.0, 0.0]
            },
            ocean: {
                color1: [0.0, 0.1, 0.2],
                color2: [0.0, 0.5, 0.7],
                color3: [0.4, 0.9, 1.0]
            },
            alien: {
                color1: [0.1, 0.2, 0.0],
                color2: [0.4, 1.0, 0.0],
                color3: [0.8, 0.0, 1.0]
            }
        };
        
        let currentPalette = palettes.cosmic;
        
        // Lighting state
        let lighting = {
            directional: true,
            ambientOcclusion: true,
            glow: true,
            shadows: true
        };

        // Input handlers
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Update camera based on input
        function updateCamera() {
            const speed = keys['shift'] ? camera.moveSpeed * 3 : camera.moveSpeed;
            
            // Rotation
            if (keys['arrowleft']) camera.rot[1] -= camera.rotSpeed;
            if (keys['arrowright']) camera.rot[1] += camera.rotSpeed;
            if (keys['arrowup']) camera.rot[0] -= camera.rotSpeed;
            if (keys['arrowdown']) camera.rot[0] += camera.rotSpeed;
            
            // Create rotation matrix
            const yaw = camera.rot[1];
            const pitch = camera.rot[0];
            
            const forward = [
                Math.sin(yaw) * Math.cos(pitch),
                Math.sin(pitch),
                Math.cos(yaw) * Math.cos(pitch)
            ];
            
            const right = [
                Math.cos(yaw),
                0,
                -Math.sin(yaw)
            ];
            
            const up = [0, 1, 0];
            
            // Movement
            if (keys['w']) {
                camera.pos[0] += forward[0] * speed;
                camera.pos[1] += forward[1] * speed;
                camera.pos[2] += forward[2] * speed;
            }
            if (keys['s']) {
                camera.pos[0] -= forward[0] * speed;
                camera.pos[1] -= forward[1] * speed;
                camera.pos[2] -= forward[2] * speed;
            }
            if (keys['a']) {
                camera.pos[0] -= right[0] * speed;
                camera.pos[2] -= right[2] * speed;
            }
            if (keys['d']) {
                camera.pos[0] += right[0] * speed;
                camera.pos[2] += right[2] * speed;
            }
            if (keys['q']) camera.pos[1] -= speed;
            if (keys['e']) camera.pos[1] += speed;
        }

        // Create camera rotation matrix
        function getCameraMatrix() {
            const yaw = camera.rot[1];
            const pitch = camera.rot[0];
            
            const cy = Math.cos(yaw);
            const sy = Math.sin(yaw);
            const cp = Math.cos(pitch);
            const sp = Math.sin(pitch);
            
            return [
                cy, 0, -sy,
                sy * sp, cp, cy * sp,
                sy * cp, -sp, cy * cp
            ];
        }

        // Animation system
        let isPlaying = false;
        let animationPhase = 0; // 0=X, 1=Y, 2=Z, 3=W, 4=ALL
        let animationTime = 0;
        let animationSpeed = 0.5; // Full cycle in 2 seconds (there and back = 4 seconds)
        const playButton = document.getElementById('play-button');
        const animationStatus = document.getElementById('animation-status');
        
        // Store initial values for animation
        let baseJuliaC = [...juliaC];
        
        const phaseNames = ['Animating X', 'Animating Y', 'Animating Z', 'Animating W', 'Animating All'];
        
        function updateAnimation(deltaTime) {
            if (!isPlaying) return;
            
            animationTime += deltaTime * 0.001 * animationSpeed;
            
            // Create a smooth oscillation from -2 to 2 and back
            const t = (Math.sin(animationTime * Math.PI) + 1) / 2; // 0 to 1 to 0
            const value = -2 + t * 4; // -2 to 2
            
            // Update status display
            animationStatus.textContent = phaseNames[animationPhase];
            
            // Reset to base values
            juliaC = [...baseJuliaC];
            
            // Apply animation based on phase
            switch(animationPhase) {
                case 0: // Animate X
                    juliaC[0] = value;
                    kxSlider.value = value;
                    break;
                case 1: // Animate Y
                    juliaC[1] = value;
                    kySlider.value = value;
                    break;
                case 2: // Animate Z
                    juliaC[2] = value;
                    kzSlider.value = value;
                    break;
                case 3: // Animate W
                    juliaC[3] = value;
                    kwSlider.value = value;
                    break;
                case 4: // Animate all
                    juliaC[0] = value;
                    juliaC[1] = -value; // Opposite direction for variety
                    juliaC[2] = value;
                    juliaC[3] = -value;
                    kxSlider.value = value;
                    kySlider.value = -value;
                    kzSlider.value = value;
                    kwSlider.value = -value;
                    break;
            }
            
            updateSliderDisplays();
            
            // Check if we completed a full cycle (back to start)
            if (animationTime >= 2) {
                animationTime = 0;
                animationPhase = (animationPhase + 1) % 5;
                
                // If we completed all phases, restart
                if (animationPhase === 0) {
                    baseJuliaC = [...juliaC];
                }
            }
        }
        
        function toggleAnimation() {
            isPlaying = !isPlaying;
            
            if (isPlaying) {
                playButton.textContent = '⏸ Pause Animation';
                playButton.classList.add('playing');
                
                // Store current values as base
                baseJuliaC = [...juliaC];
                animationTime = 0;
                animationPhase = 0;
                
                // Disable manual controls
                kxSlider.disabled = true;
                kySlider.disabled = true;
                kzSlider.disabled = true;
                kwSlider.disabled = true;
                sliceSlider.disabled = true;
                document.getElementById('random-julia').disabled = true;
            } else {
                playButton.textContent = '▶ Play Animation';
                playButton.classList.remove('playing');
                animationStatus.textContent = '';
                
                // Re-enable manual controls
                kxSlider.disabled = false;
                kySlider.disabled = false;
                kzSlider.disabled = false;
                kwSlider.disabled = false;
                sliceSlider.disabled = false;
                document.getElementById('random-julia').disabled = false;
            }
        }
        
        playButton.addEventListener('click', toggleAnimation);
        
        // UI Controls
        const kxSlider = document.getElementById('kx');
        const kySlider = document.getElementById('ky');
        const kzSlider = document.getElementById('kz');
        const kwSlider = document.getElementById('kw');
        const sliceSlider = document.getElementById('slice');
        const iterationsSlider = document.getElementById('iterations');
        
        // Update displays
        function updateSliderDisplays() {
            document.getElementById('kx-val').textContent = parseFloat(kxSlider.value).toFixed(2);
            document.getElementById('ky-val').textContent = parseFloat(kySlider.value).toFixed(2);
            document.getElementById('kz-val').textContent = parseFloat(kzSlider.value).toFixed(2);
            document.getElementById('kw-val').textContent = parseFloat(kwSlider.value).toFixed(2);
            document.getElementById('slice-val').textContent = parseFloat(sliceSlider.value).toFixed(2);
            document.getElementById('iterations-val').textContent = iterationsSlider.value;
        }
        
        kxSlider.addEventListener('input', () => {
            juliaC[0] = parseFloat(kxSlider.value);
            updateSliderDisplays();
        });
        
        kySlider.addEventListener('input', () => {
            juliaC[1] = parseFloat(kySlider.value);
            updateSliderDisplays();
        });
        
        kzSlider.addEventListener('input', () => {
            juliaC[2] = parseFloat(kzSlider.value);
            updateSliderDisplays();
        });
        
        kwSlider.addEventListener('input', () => {
            juliaC[3] = parseFloat(kwSlider.value);
            updateSliderDisplays();
        });
        
        sliceSlider.addEventListener('input', () => {
            sliceW = parseFloat(sliceSlider.value);
            updateSliderDisplays();
        });
        
        iterationsSlider.addEventListener('input', () => {
            iterations = parseInt(iterationsSlider.value);
            updateSliderDisplays();
        });
        
        // Palette controls
        const paletteSelect = document.getElementById('palette-preset');
        const customColors = document.getElementById('custom-colors');
        
        // Populate palette dropdown
        const paletteOptions = [
            { value: 'cosmic', text: 'Cosmic' },
            { value: 'fire', text: 'Fire' },
            { value: 'ocean', text: 'Ocean' },
            { value: 'alien', text: 'Alien' },
            { value: 'custom', text: 'Custom' }
        ];
        
        paletteOptions.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.text;
            paletteSelect.appendChild(option);
        });
        
        // Log to verify options were added
        console.log('Palette options added:', paletteSelect.options.length, 'options');
        
        paletteSelect.addEventListener('change', () => {
            if (paletteSelect.value === 'custom') {
                customColors.style.display = 'block';
                // Set custom palette to current colors
                currentPalette = {
                    color1: hexToRgb(document.getElementById('color1').value),
                    color2: hexToRgb(document.getElementById('color2').value),
                    color3: hexToRgb(document.getElementById('color3').value)
                };
            } else {
                customColors.style.display = 'none';
                currentPalette = palettes[paletteSelect.value];
            }
        });
        
        // Custom color pickers
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255
            ] : null;
        }
        
        document.getElementById('color1').addEventListener('input', (e) => {
            if (paletteSelect.value === 'custom') {
                currentPalette.color1 = hexToRgb(e.target.value);
            }
        });
        
        document.getElementById('color2').addEventListener('input', (e) => {
            if (paletteSelect.value === 'custom') {
                currentPalette.color2 = hexToRgb(e.target.value);
            }
        });
        
        document.getElementById('color3').addEventListener('input', (e) => {
            if (paletteSelect.value === 'custom') {
                currentPalette.color3 = hexToRgb(e.target.value);
            }
        });
        
        // Lighting controls
        document.getElementById('directional').addEventListener('change', (e) => {
            lighting.directional = e.target.checked;
        });
        
        document.getElementById('ambient-occlusion').addEventListener('change', (e) => {
            lighting.ambientOcclusion = e.target.checked;
        });
        
        document.getElementById('glow').addEventListener('change', (e) => {
            lighting.glow = e.target.checked;
        });
        
        document.getElementById('shadows').addEventListener('change', (e) => {
            lighting.shadows = e.target.checked;
        });
        
        // Buttons
        document.getElementById('reset-camera').addEventListener('click', () => {
            camera.pos = [0, 0, -3];
            camera.rot = [0, 0];
        });
        
        document.getElementById('random-julia').addEventListener('click', () => {
            kxSlider.value = (Math.random() * 4 - 2).toFixed(2);
            kySlider.value = (Math.random() * 4 - 2).toFixed(2);
            kzSlider.value = (Math.random() * 4 - 2).toFixed(2);
            kwSlider.value = (Math.random() * 4 - 2).toFixed(2);
            
            juliaC[0] = parseFloat(kxSlider.value);
            juliaC[1] = parseFloat(kySlider.value);
            juliaC[2] = parseFloat(kzSlider.value);
            juliaC[3] = parseFloat(kwSlider.value);
            
            updateSliderDisplays();
        });
        
        document.getElementById('screenshot').addEventListener('click', () => {
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quaternion-julia-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        });

        // FPS counter
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;
        
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            const delta = currentTime - lastTime;
            
            if (delta >= 1000) {
                fps = Math.round(frameCount * 1000 / delta);
                document.getElementById('fps').textContent = `FPS: ${fps} | ${canvas.width}x${canvas.height}`;
                frameCount = 0;
                lastTime = currentTime;
                
                // Auto-adjust quality based on FPS
                if (fps < 20 && currentScale > 0.25) {
                    currentScale *= 0.9;
                    targetWidth = Math.floor(3840 * currentScale);
                    targetHeight = Math.floor(2160 * currentScale);
                    resizeCanvas();
                } else if (fps > 50 && currentScale < 1.0) {
                    currentScale = Math.min(currentScale * 1.1, 1.0);
                    targetWidth = Math.floor(3840 * currentScale);
                    targetHeight = Math.floor(2160 * currentScale);
                    resizeCanvas();
                }
            }
        }

        // Render loop
        let lastFrameTime = 0;
        
        function render(time) {
            const deltaTime = time - lastFrameTime;
            lastFrameTime = time;
            
            updateCamera();
            updateAnimation(deltaTime);
            updateFPS();
            
            gl.useProgram(program);
            
            // Set uniforms
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.time, time * 0.001);
            gl.uniform4fv(uniforms.juliaC, juliaC);
            gl.uniform3fv(uniforms.cameraPos, camera.pos);
            gl.uniformMatrix3fv(uniforms.cameraRot, false, getCameraMatrix());
            gl.uniform1f(uniforms.sliceW, sliceW);
            gl.uniform1i(uniforms.iterations, iterations);
            
            // Colors
            gl.uniform3fv(uniforms.color1, currentPalette.color1);
            gl.uniform3fv(uniforms.color2, currentPalette.color2);
            gl.uniform3fv(uniforms.color3, currentPalette.color3);
            
            // Lighting
            gl.uniform1i(uniforms.directional, lighting.directional);
            gl.uniform1i(uniforms.ambientOcclusion, lighting.ambientOcclusion);
            gl.uniform1i(uniforms.glow, lighting.glow);
            gl.uniform1i(uniforms.shadows, lighting.shadows);
            
            // Bind vertex buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        // Start rendering
        requestAnimationFrame(render);
    </script>
</body>
</html>